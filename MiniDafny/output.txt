(set-option :print-success false)
(set-option :produce-models true)
(set-logic UFLIA)
(push 1)
(declare-sort intarray 0)
(declare-fun update (intarray Int Int) intarray)
(declare-fun select (intarray Int) Int)
(declare-fun x () Int)
(declare-fun x0 () Int)
(declare-fun xa2 () Int)
(declare-fun xa1 () Int)
(declare-fun a0 () Int)
(declare-fun a () intarray)
(declare-fun x1 () Int)
(declare-fun aa1 () Int)
(declare-fun aa2 () Int)
(declare-fun Assert () Bool)
(declare-fun xa3 () Int)
(declare-fun aLength () Int)
(assert (not (=> (forall ((x Int)) (=> (and (<= 0 x) (< x aLength)) (= (select a x) 0))) (=> (= x0 x) (=> (= xa3 0) (and (and (and (and (<= 0 xa3) (<= xa3 aLength)) (forall ((y Int)) (=> (and (<= 0 y) (< y x)) (= (select a x) 1)))) (forall ((y Int)) (=> (and (<= x y) (< y aLength)) (= (select a x) 0)))) (=> (and (and (and (<= 0 xa2) (<= xa2 aLength)) (forall ((y Int)) (=> (and (<= 0 y) (< y x)) (= (select a x) 1)))) (forall ((y Int)) (=> (and (<= x y) (< y aLength)) (= (select a x) 0)))) (and (=> (< xa2 aLength) (=> (= a0 aa2) (=> (= aa1 (select (update a x (+ (select a x) 1)) x)) (=> (= x1 xa2) (=> (= xa1 (+ x1 1)) (and (and (and (and (<= 0 xa1) (<= xa1 aLength)) (forall ((y Int)) (=> (and (<= 0 y) (< y x)) (= (select a x) 1)))) (forall ((y Int)) (=> (and (<= x y) (< y aLength)) (= (select a x) 0)))) (=> false (and (or (forall ((x Int)) (=> (and (<= 0 x) (< x aLength)) (= (select a x) 1))) Assert) true)))))))) (=> (not (< xa2 aLength)) (and (or (forall ((x Int)) (=> (and (<= 0 x) (< x aLength)) (= (select a x) 1))) Assert) true))))))))))
(check-sat)
(get-model)
(pop 1)
